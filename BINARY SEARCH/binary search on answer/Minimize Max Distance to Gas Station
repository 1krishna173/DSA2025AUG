We have a horizontal number line. On that number line, we have gas stations at positions stations[0], stations[1], ..., stations[n-1]. Now, we add k more gas stations so that d, the maximum distance between adjacent gas stations, is minimized. We have to find the smallest possible value of d. Find the answer exactly to 2 decimal places.
Note: stations is in a strictly increasing order.

Input: stations[] = [1, 2, 3, 4, 5], k = 2
Output: 1.00
Explanation: Since all gaps are already equal (1 unit each), adding extra stations in between does not reduce the maximum distance.
Input: stations[] = [3, 6, 12, 19, 33], k = 3
Output: 6.00 
Explanation: The largest gap is 14 (between 19 and 33). Adding 2 stations there splits it into approx 4.67. The next largest gap is 7 (between 12 and 19). Adding 1 station splits it into 3.5. Now the maximum gap left is 6.

class Solution {
  public:
    double minMaxDist(vector<int> &stations, int k) {
        // Code here
        int n=stations.size();
        vector<int> howmany(n-1,0);
        priority_queue<pair<double,int>> pq;
        for(int i=0;i<n-1;i++){
            double diff=stations[i+1]-stations[i];
            pq.push({diff,i});
        }
        for(int i=0;i<k;i++){
           auto temp=pq.top();pq.pop();
           int index=temp.second;
          howmany[index]++;
           int initdiff=stations[index+1]-stations[index];
           double segment=initdiff/(double)(howmany[index]+1);
           pq.push({segment,index});
        }
       
        return pq.top().first;
    }   
};
